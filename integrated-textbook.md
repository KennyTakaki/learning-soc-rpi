# Raspberry Pi 5 で学ぶ ARM・Linux・ISP テキストブック  
**Ver. 1.1 / Author: Kentarou Takaki**  
（実機トラック × 思考実験トラックの統合版）

---

## 目次
- 第0章：全体像と学習設計  
- 第1章：Raspberry Pi 5 のハードウェア全体像  
- 第2章：OSとLinuxカーネルの起動プロセス  
- 第3章：デバイスI/O（GPIO/UART/I²C）  
- 第4章：カメラインターフェース（MIPI/CSI → V4L2/libcamera）  
- 第5章：ISP（Image Signal Processor）理解とGStreamer  
- 第6章：開発・検証環境構築（ヘッドレス/冷却/記録）  
- 第7章：はじめてのカーネルモジュール（ドライバ入門）  
- 第8章：層で理解するSoC×OSの地図（統合復習）  
- 第9章：頭の中から実機へ（QEMU/U-Boot/Yocto/他SoC比較）  
- Appendix：推奨ハードウェア・参考コマンド集

---

## 🧭 第0章：全体像と学習設計

本書は Raspberry Pi 5 を題材に、**ARM SoC／Linux カーネル／Device Tree／MIPI/ISP／GStreamer** を段階的に学ぶ**実践×思考実験**ノートです。各章にチェックボックスがあり、**理解→実験→記録**のサイクルで進めます。

### 学習対象の全体構造（階層図）

```mermaid
flowchart TD
  A["Pi5 学習全体像"] --> B["ハードウェア基礎"]
  A --> C["OSとLinuxカーネル"]
  A --> D["デバイスI/O制御"]
  A --> E["カメラインターフェース（MIPI/CSI）"]
  A --> F["ISPと画像処理"]
  A --> G["GStreamerパイプライン"]
  A --> H["開発・検証環境"]

  B --> B1["ARM CPU/SoC構造"]
  B --> B2["メモリ/PCIe/周辺I/O"]
  C --> C1["ブートシーケンス"]
  C --> C2["デバイスツリー"]
  D --> D1["GPIO/UART"]
  D --> D2["I2C/SPI"]
  E --> E1["CSI2信号/レーン"]
  E --> E2["libcamera/V4L2"]
  F --> F1["RAW→YUV/ISP段"]
  F --> F2["HWエンコード"]
  G --> G1["設計/可視化"]
  G --> G2["HWアクセラレーション"]
  H --> H1["Imager/SSH/VSCode"]
  H --> H2["電源/冷却/ストレージ"]

```
## 🔋 第0.5章：電源と信号の電気的基礎（PMIC／GND／受動部品）

**対象**：B（ハードウェア基礎）
**レベル感**：

* 理解：電源が **SoC を動かす「物理レイヤ」** であることを意識できる
* 実践：Pi 5 の電源構成・GND・ノイズの関係を**自分の図で整理**できる

**完了期待**

* Raspberry Pi 5 の **PMIC（電源管理 IC）** が何をしているか説明できる
* SoC の **データプレーン／コントロールプレーン と 電源プレーン** の違いを言葉で説明できる
* **GND フローティング** がなぜ危ないかを具体例とセットで説明できる
* **インダクタ／コンデンサ** の役割を「回路として」説明できる

---

## Raspberry Pi 5 の PMIC（電源管理 IC）とは？

Pi 5 では、**DA9091（Dialog / Renesas）** 系の PMIC が載っていて、
「5V を SoC が使える複数の電圧に変換しつつ、きれいに安定させる」役割を持っている。

### PMIC が担当していること（ざっくり）

| 機能                        | 具体例                                                 |
| ------------------------- | --------------------------------------------------- |
| **降圧/昇圧（Step-down / up）** | 5V → 1.8V / 1.1V / 0.9V … など、SoC 向け電圧を生成            |
| **電流供給の安定化**              | 数 A クラスの電流を瞬時に供給し、CPU 負荷変動に追従                       |
| **複数レールの生成**              | VDD_CORE / VDD_GPU / VDD_SRAM / VDD_IO / VDD_CAM など |
| **パワーシーケンス制御**            | 「どの電圧をどの順番で立ち上げるか」を制御（起動シーケンス）                      |
| **保護機能**                  | 過電流／過温度／低電圧（UVLO）などからシステムを保護                        |

**ポイント**：

* **SoC 自身は電圧を作らない**
* 「電源プレーン」を作っているのは **PMIC + 受動部品（L/C）側**

---

##  SoC と電源（PMIC）の切り分け

― データプレーン／コントロールプレーンのさらに外側にある「パワープレーン」

あなたの中で整理したい概念：

* **データプレーン**：映像・PCIe・USB3 など **大容量データ** の通り道
* **コントロールプレーン**：GPIO / I²C / SPI / UART など **制御・設定** の通り道
* その外側に、これらをそもそも動かすための **パワープレーン（電源）** がある

### SoC を支える 3 つのプレーン（層）

```text
1. Power Plane（電源）
  ├─ PMIC（電圧生成・安定化）
  ├─ GND（基準点）
  ├─ 電源レール（1.1V / 1.8V / 3.3V など）
  → SoC の「生命維持装置」

2. Control Plane（制御信号）
  ├─ I²C（センサ設定）
  ├─ SPI（レジスタ・低速データ）
  └─ GPIO（On / Off）

3. Data Plane（大容量データ）
  ├─ PCIe（NVMe など）
  ├─ MIPI CSI / DSI（カメラ／ディスプレイ）
  └─ USB3 / HDMI
```

**ここでの学び**

* SoC は **データ／制御ロジック** を持つが、**電圧そのものは作らない**
* 電圧が乱れると、データプレーン・コントロールプレーン **両方が巻き込まれて壊れる**
* PMIC は SoC にとって **「心臓＋血圧コントローラ」** に近い存在

---

## なぜ GND（グラウンド）が浮くと危険なのか？

### GND の役割

* すべての電圧は **「GND との電位差」** で定義される
  → 3.3V とは **VDD − GND = 3.3V**
* デジタル回路の **HIGH / LOW の閾値** も、GND を基準に決まっている

### 「GND が浮く（フローティング）」とは？

* GND がしっかりボード全体で共有されていない
* ケーブルが細い／長い・接触不良・大電流で配線が電位上昇…などで
* **本来 0V であってほしい GND の電位が、じわっと持ち上がってしまう状態**

### その結果どうなるか

1. 「3.3V のつもり」が実質 **3.0V / 2.8V** になってしまう
2. デジタル回路の HIGH/LOW 判定の閾値がずれて、**誤動作**
3. 高速バス（CSI / PCIe / USB3）が **ビットエラー／リンクダウン**
4. 最悪の場合、絶対最大定格を超えて **SoC／周辺デバイスが破損**
5. GND 経由でノイズが他の回路に回り込み、**クロストーク** が増える

### 具体例イメージ

* カメラ基板側の GND が弱い
* CSI の差動信号が、カメラ側と SoC 側で「基準点」がズレる
* 差動ペアの片側が OverShoot／UnderShoot して、**受信側でビット化け**
* フレームドロップ・画像の乱れ・カメラ認識失敗 などにつながる

---

## インダクタ（L）とコンデンサ（C）の役割

― 「電源を物理レベルでならす・ためる部品」

PMIC の周りを見ると、必ず **インダクタ（L）** と **コンデンサ（C）** がセットで並んでいる。
これは飾りではなく、**電源を安定させるための主役級パーツ**。

---

### コンデンサ（C）のイメージ

> **電荷をためて、必要なときに一瞬で吐き出せる「ミニバッテリー」**

**主な役割**

* 電圧をなめらかにする（リップル成分を吸収）
* CPU が瞬間的に大電流を引いたとき、**一時的に電荷を供給**して電圧降下を防ぐ
* 高周波ノイズをバイパスして、回路から追い出す（デカップリングコンデンサ）

**比喩**

```text
・電圧の揺れを抑えるダンパー
・急ブレーキ時にショックを吸収するサスペンション
```

---

### インダクタ（L）のイメージ

> **電流の「変化」に抵抗するバネのような部品**

**主な役割**

* スイッチング電源で、電流をならして一定に近づける
* 電流が急に増えたり減ったりするのを嫌い、**急変を抑えてノイズを減らす**

**比喩**

```text
電流が急に増える → 「ちょっと待て」と引き止める
電流が急に減る → 「戻れ戻れ」と引っ張り戻す
```

---

### PMIC 周りの L/C フィルタで実際に起きていること

```text
5V →（PMIC のスイッチング）→ L → C → 安定した 1.1V
```

* PMIC は内部のスイッチを高速で ON/OFF しながら平均的な電圧を作っている
* その「ギザギザした電圧／電流」を **L と C がなめらかな波に整形**
* 結果として SoC の各ブロックは **安定した電源レール** で動作できる

---

## 電源と高速信号（CSI / PCIe / USB）の関係

高速 I/O すべてに共通する前提：

* **電源と GND が安定していることが大前提**

| インターフェース   |        周波数のイメージ | 特に重要なポイント               |
| ---------- | --------------: | ----------------------- |
| MIPI CSI-2 | ～ 2 Gbps / レーン級 | 低ノイズ・安定した GND とリファレンス   |
| PCIe Gen2  |        5.0 Gbps | 電源揺れでリンクダウンしやすい         |
| USB3       |          5 Gbps | ノイズでパケットエラー             |
| HDMI 4K60  |        数 Gbps 級 | 電源/GND 不良でブラックアウトやノイズ画面 |

* 電源が揺れる → **信号の 0V 基準が揺れて見える**
* 差動信号の片側が規格外のレベルまで振れて、**アイパターンが崩れる**
* 結果として、**CRC エラー／再送／フレームドロップ** という形で表面化する

---

## 📝 実施チェックラン（第0.5章）

* [ ] Raspberry Pi 5 の PMIC（DA9091）周りのブロック図を自作した
* [ ] SoC の **Power / Control / Data プレーン** を 1 枚の図にまとめた
* [ ] 「GND フローティングが起きる状況」と「その結果の不具合」を文章で整理した
* [ ] コンデンサ／インダクタの役割を、自分なりの比喩つきでメモした
* [ ] NVMe HAT ＋ Pi 5 で電源不足が起きうるシナリオを想像し、ノートに書いた

---

## 🧠 思考実験：電源トラブルを頭の中で再生する

1. CPU がブーストしてクロックアップ → 瞬間的に電流が増える
2. PMIC が追従しきれない瞬間が生まれる
3. 近傍のコンデンサが電荷を絞り出して補うが、容量には限界がある
4. 一瞬、電圧が落ちる → SoC 内の PLL や高速 I/O のマージンが削られる
5. USB / CSI / PCIe でエラーが出る → Linux 側では再ネゴシエーションやリンクダウン
6. `dmesg` に `link down` / `crc error` / `undervoltage` などのログが残る

→ 「ソフトから見ると I/O エラーだが、根本原因は電源だった」という世界がイメージできれば OK。

---

## Appendix（電源まわりの観察コマンド）

```bash
# コア電圧の確認（環境によって項目名は変わる可能性あり）
vcgencmd measure_volts core

# ARM コアクロックの確認
vcgencmd measure_clock arm

# 電源不足（Undervoltage）に関するログを探す
dmesg | grep -i voltage
```

この章を、もとのテキストの **第0章と第1章の間（第0.5章）** として差し込めば、
「電気的な土台 → ハード構造 → ブートプロセス」という流れがきれいにつながるはずです。


## 📘 第1章：Raspberry Pi 5 のハードウェア全体像

**対象コンポーネント**：B（ハードウェア基礎）  
**レベル感**：  
- 理解：構造を**説明できる**  
- 実践：主要**ブロック図を自作**できる

**完了期待**  
- BCM2712 SoC（Cortex-A76×4, VideoCore VII, PCIe 他）と周辺の関係を説明できる  
- CSI/DSI/HDMI/USB/GPIOの役割と位置づけを整理できる

**実施チェックラン**  
- [x] Pi 5 の**ブロック図**を自作（CPU/GPU/ISP/DDR/PCIe/USB/CSI/DSI/HDMI/GPIO）  
- [x] **電源**（5V/5A）・**映像**（micro-HDMI 4K60×2）・**ストレージ**（microSD/PCIe-NVMe）を確認  
- [ ] NVMe HATやUSB3構成の**配線案**を描いた

**頭の中で動かす（思考実験）**  
```
[BCM2712 SoC]
├─ Cortex-A76 CPU × 4 (AArch64)
├─ GPU: VideoCore VII（ISP/メディアブロックと隣接）
├─ DDR Controller ── LPDDR
├─ I/O: PCIe / USB / GbE / HDMI x2 / CSI2 / DSI
└─ Low-speed: GPIO / I²C / SPI / UART
```
→ **問い**：CSIで入ったRAWが、どのブロックを経て表示/エンコードに至るかを線で結ぶ。

低速系に関しては以下を理解しておく。
| 種類                   | 役割                  | 帯域 | 用途                     | データの流れ            |
| -------------------- | ------------------- | -- | ---------------------- | ----------------- |
| **GPIO**             | ピンをON/OFFするだけの最小の制御 | 最低 | LED・リレー制御・単純センサ        | 1bitの状態（High/Low） |
| **I²C**              | 低速の制御バス（多デバイス）      | 低  | センサ設定、レジスタ読み書き         | シリアル、アドレスあり       |
| **SPI**              | 高速のストリーム制御バス        | 中  | ADC, DAC, ディスプレイ、フラッシュ | クロック同期ストリーム       |
| **UART**             | 非同期のテキスト通信          | 低  | マイコン、GPS、モデム           | バイト列（Tx/Rx）       |
| **MIPI CSI/DSI etc** | **超高速データプレーン**      | 高  | カメラ映像、ディスプレイ           | フレーム/画像データ        |


---

## 📗 第2章：OSとLinuxカーネルの起動プロセス

**対象**：C（OS/カーネル）  
**レベル感**：  
- 理解：ブートの**流れを説明**  
- 実践：Device Tree を**読んで対応関係を確認**

**完了期待**  
- BootROM → bootloader → firmware → kernel → init のシーケンスを説明  
- `/proc/device-tree`と`dmesg`から**実機構成を読み解く**

**実施チェックラン**  
- [x] ブートローダとカーネルの**役割**を説明  
- [x] `cat /proc/device-tree/model` を確認  
- [x] `dmesg`で**カメラ/ISP/PCIe**初期化ログを探索  
- [x] `/boot`, `/lib/modules`, `/proc` の**役割**を整理

**思考実験：想定コマンドと観察ポイント**
```bash
dmesg | less                 # デバイス初期化の時系列
ls /proc/device-tree         # ノードの構成
```
学び：**DTBが「ハード構成の真実源」**で、ドライバはこれを読み込んで登録される。

---

## 📙 第3章：デバイスI/Oと制御（GPIO/UART/I²C）

**対象**：D（I/O制御）  
**レベル感**：  
- 理解：GPIO/UART/I²C の**仕組み**  
- 実践：LED点灯・シリアル通信の**最小実験**

**完了期待**  
- GPIO入出力制御ができ、**ピン多重化（mux）**の重要性を理解  
- UART/I²C の信号・役割・典型配線を説明

**実施チェックラン**  
- [ ] Python/Cいずれかで**GPIO制御**を実施（LED点灯）  
- [ ] UARTで**ループバック**または外部機器と通信  
- [ ] `raspi-gpio get` でピン状態を確認  
- [ ] **MIPIピンとGPIOピン**の違いを整理

**思考実験：/sys 経由の制御モデル**
```bash
echo 18 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio18/direction
echo 1 > /sys/class/gpio/gpio18/value
```
学び：**「すべてはファイル」**。ユーザ空間I/Oはドライバ抽象を経てMMIOに到達。

---

## 📕 第4章：カメラインターフェース（MIPI/CSI → V4L2/libcamera）

**対象**：E（カメラインターフェース）  
**レベル感**：  
- 理解：CSI2 の**クロック＋データレーン**と帯域  
- 実践：**libcamera**でプレビュー／**v4l2-ctl**で列挙・取得

**完了期待**  
- **物理層（CSI2）**と**Linuxのメディア層（V4L2）**の切り分けを説明  
- `/dev/video*` とドライバの対応、**センサ( I²C )の役割**がわかる

**実施チェックラン**  
- [ ] カメラセンサの**レーン数/解像度/フレームレート**整理  
- [ ] `v4l2-ctl --list-devices` でノード確認  
- [ ] `libcamera-hello` などでプレビュー取得  
- [ ] **媒体グラフ**（センサ→CSI Rx→ISP→V4L2）を描画

**思考実験：想定コマンド**
```bash
v4l2-ctl --list-devices
v4l2-ctl -d /dev/video0 --stream-mmap --stream-count=60 --stream-to=frame.raw
```
学び：**I²C**はセンサ設定、**CSI2**は高速データ搬送、**V4L2**はユーザ空間の標準API。

**参考**

https://www.youtube.com/watch?v=ziBRtB8E6Ps&t=193s
https://www.indoorcorgielec.com/resources/raspberry-pi/camera-setup/

よめ：https://zenn.dev/thorie/scraps/663b022248e67a　☆

よめ：https://docs.freenove.com/projects/fnk0056/en/latest/fnk0056/codes/tutorial/Get_Started.html　☆
---

## 📒 第5章：ISP理解とGStreamer

**対象**：F（ISP/画像処理）＆ G（GStreamer）  
**レベル感**：  
- 理解：RAW→デモザイク→NR→AWB→CCM→YUV→圧縮 の**処理鎖**  
- 実践：GStreamerで**プレビュー/エンコード**を通す

**完了期待**  
- Pi 5 の**ISPがメディアブロック側**で動く概念を理解  
- **HWエンコード（H.264/H.265）**をパイプラインで試行できる

**実施チェックラン**  
- [ ] **RAW vs YUV**の違い・用途を説明  
- [ ] `v4l2src → （変換） → kmssink` を実行  
- [ ] H.264/H.265 の**HWエンコード**テスト  
- [ ] 自作の**ISPパス図**を作成

**思考実験：最小パイプライン設計**
```bash
# 例：取得→表示（環境に応じて要素名は調整）
gst-launch-1.0 v4l2src ! videoconvert ! kmssink
# 例：取得→H.264保存
gst-launch-1.0 v4l2src ! videoconvert ! x264enc tune=zerolatency ! mp4mux ! filesink location=out.mp4
```
学び：**ゼロコピー/色空間/同期**などパイプライン設計の勘所を掴む。

---

## 📔 第6章：開発・検証環境構築（ヘッドレス/冷却/記録）

**対象**：H（開発・検証環境）  
**レベル感**：  
- 理解：**セットアップ全体**  
- 実践：**ヘッドレス開発**（SSH/VSCode）と**安定稼働**

**完了期待**  
- ImagerでOS書込み→Wi-Fi/SSH設定→起動の一連を自力で  
- ファン/ヒートシンク/電源/ストレージを**安定構成**に

**実施チェックラン**  
- [ ] ImagerでA2カード（V30/U3）にOSを書込み  
- [ ] ヘッドレス設定（`userconf`, `wpa_supplicant.conf`, SSH）  
- [ ] VSCode Remote SSH接続  
- [ ] `vcgencmd measure_temp` で温度監視  
- [ ] micro-HDMIで映像確認 / NVMe HAT構成の試走

**思考実験：運用の型**  
- 温度上昇時の**スロットリング**の挙動を`dmesg`で観察する絵を想像  
- SDとNVMeの**I/Oプロファイル差**をメモに取る（読み/書き/レイテンシ）

---

## 🧪 第7章：はじめてのカーネルモジュール（ドライバ入門）

**対象**：カーネル/ドライバの導入口  
**レベル感**：  
- 理解：**module_init/module_exit**とデバイスモデル  
- 実践：GPIOを点滅させる**最小モジュール**をビルド/挿入

**完了期待**  
- カーネルビルドツリーの**どこを見るか**がわかる  
- `insmod`/`rmmod`/`modinfo` の意味を説明できる

**実施チェックラン**  
- [ ] `make -C /lib/modules/$(uname -r)/build M=$(pwd) modules` でビルド  
- [ ] `sudo insmod`→動作→`sudo rmmod`  
- [ ] `dmesg`でモジュールログを確認  
- [ ] **GPLライセンス宣言**の意味を理解

**思考実験：骨格を読む**
```c
module_init(init_fn);
module_exit(exit_fn);
struct file_operations ...;     // ユーザ空間IF
struct platform_driver ...;     // OFマッチ/プローブ
```
学び：**OF(=Device Tree)とのマッチ→プローブ→レジスタ I/O**の流れが核。

---

## 🧩 第8章：層で理解する SoC × OS の地図（統合復習）

```
┌───────────────────────────┐
│ User Space (bash, Python, libcamera, gst) │
└────────────┬──────────────┘
             │ sysfs / ioctl / V4L2 / MMAP
┌────────────┴──────────────┐
│ Kernel (Drivers, V4L2, DRM/KMS, MM, VFS) │
└────────────┬──────────────┘
             │ MMIO / IRQ / DMA
┌────────────┴──────────────┐
│ ARM SoC (BCM2712 A76x4, VideoCore VII, CSI/ISP, I/O) │
└───────────────────────────┘
```

**完了チェック**  
- [ ] ユーザ空間API→カーネルサブシステム→ハードの**三層連携**を説明  
- [ ] **割り込み/DM A/メモリマップ**の関係を言語化

---

## 🚀 第9章：頭の中から実機へ（QEMU/U-Boot/Yocto/他SoC比較）

| 段階 | 内容 | ゴール |
|---|---|---|
| Step 1 | **QEMU**でAArch64最小Linuxを起動 | ブートの観察と構成の再現 |
| Step 2 | **U-Boot**ビルド＆起動ログ読解 | ブートローダの役割理解 |
| Step 3 | **Yocto Project**で最小ディストリ作成 | BSP構築の基礎 |
| Step 4 | **i.MX93 EVK / Jetson**比較 | ISP有無やメディアブロック差の把握 |

**思考実験の問い**  
- ISPを持たないSoC（例：i.MX93）では、RAW→YUVの**どこをソフト/外部ブロック**で補う？  
- Pi 5 の**HWエンコード**を使う/使わないで、GStreamer設計はどう変わる？

---

## 🧾 Appendix：推奨ハードウェア・参考コマンド集

### 推奨ハードウェアリスト
| 種別 | 推奨 | 備考 |
|---|---|---|
| 本体 | Raspberry Pi 5 (16GB) | 余裕あるメモリで学習しやすい |
| 電源 | USB-C 5V/5A（27W） | 安定動作に必須 |
| ストレージ | microSD A2/V30/U3（256GB+） | OS/ログ用 |
| 追加 | NVMe HAT (PCIe) | ビルド/録画I/O向上 |
| カメラ | Camera Module 3 | MIPI CSI2 |
| 冷却 | PWMファン＋ヒートシンク | スロットリング対策 |
| ケース | 金属/エアフロー型 | 放熱重視 |
| ケーブル | micro-HDMI→HDMI (4K60)×2 | デュアル出力 |

### よく使う観察コマンド
```bash
# ブートとデバイス
dmesg | less
ls /proc/device-tree
uname -a

# ピン/温度
raspi-gpio get
vcgencmd measure_temp

# カメラ/メディア
v4l2-ctl --list-devices
libcamera-hello
```

---

# 章ごとの進捗チェックひな型（コピペして使う）

```md
### ✅ 実施チェックラン（章X）
- [ ] 観察ログを保存（`logs/chX_YYYYMMDD.txt`）
- [ ] 自作図を `docs/chX_diagram_v1.drawio` に追加
- [ ] 次回の疑問点を Issue 登録（`issues/#chX`）
```

---

## 使い方メモ
- **実機トラック**：実際にPi 5で手を動かして記録  
- **思考実験トラック**：コマンドの**期待挙動**やデータフローを**頭で再生**し、図と文章で残す  
- GitHubでは、章ごとに**ログ/図/メモ/Issue
